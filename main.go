package main

import (
	"embed"
	"encoding/json"
	"flag"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"

	"github.com/SherClockHolmes/webpush-go"
)

// WebPushKeys describes the JSON object outputted by
// this command line tool.
type WebPushKeys struct {
	PrivateKey   string               `json:"privatekey"`
	PublicKey    string               `json:"publickey"`
	// the Subject is intended to be used to populate the 
	// "sub" JWT claim as described here: https://datatracker.ietf.org/doc/html/rfc8292#section-2.1
	// Note that Apple's web push endpoints in particular only appear to allow
	// email addresses without "mailto://" as the "sub", contra the spec.
	Subject      string               `json:"subject"`
	Subscription webpush.Subscription `json:"subscription"`
}

type subscriptionResult struct {
	subscription *webpush.Subscription
	err          error
}

//go:embed index.html main.js service-worker.js
var staticFiles embed.FS

func getSubscriptionTokens(vapidPublicKey string) (*webpush.Subscription, error) {
	subChan := make(chan subscriptionResult, 1)
	onError := func(err error) {
		subChan <- subscriptionResult{
			subscription: nil,
			err:          err,
		}
		close(subChan)
	}
	staticServer := http.FileServer(http.FS(staticFiles))
	http.Handle("/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == "/" {
			tmpl, err := template.ParseFS(staticFiles, "index.html")
			if err != nil {
				onError(err)
				return
			}
			w.Header().Set("Content-Type", "text/html")
			data := map[string]interface{}{
				"VAPID_PUBLIC_KEY": vapidPublicKey,
			}
			if err := tmpl.Execute(w, data); err != nil {
				onError(err)
				return
			}
		} else {
			staticServer.ServeHTTP(w, r)
		}
	}))
	http.Handle("/subscribe", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			onError(err)
			return
		}
		var subscription webpush.Subscription
		err = json.Unmarshal(body, &subscription)
		if err != nil {
			onError(err)
			return
		}
		subChan <- subscriptionResult{
			subscription: &subscription,
			err:          nil,
		}
		close(subChan)
	}))
	go http.ListenAndServe(":8080", nil)
	cmd := exec.Command("open", "http://localhost:8080")
	if _, err := cmd.Output(); err != nil {
		onError(err)
	}
	result := <-subChan
	return result.subscription, result.err
}

func main() {
	var subject string
	var test bool
	flag.StringVar(&subject, "subject", "", "used to populate the 'sub' claim in the web push JWT")
	flag.BoolVar(&test, "test", false, "whether to perform an immediate test web push send using the credentials generated by this tool")
	flag.Parse()

	privateKey, publicKey, err := webpush.GenerateVAPIDKeys()
	if err != nil {
		log.Fatalf("failed to generate VAPID key pair: %v", err)
	}
	subscription, err := getSubscriptionTokens(publicKey)
	if err != nil || subscription == nil {
		log.Fatalf("failed to register subscription in browser: %v", err)
	}
	if test {
		msg, _ := json.Marshal(map[string]interface{}{
			"title": "Test web push",
			"body":  "The body of your message goes here.",
			"url":   "https://wikipedia.org",
		})
		res, err := webpush.SendNotification(msg, subscription, &webpush.Options{
			Subscriber:      subject,
			VAPIDPublicKey:  publicKey,
			VAPIDPrivateKey: privateKey,
			TTL:             30,
		})
		if err != nil {
			log.Fatalf("failed to test send: %v", err)
		}
		if res.StatusCode >= 400 {
			log.Fatalf("bad response from test send: %v", res)
		}
	}
	json.NewEncoder(os.Stdout).Encode(WebPushKeys{
		PrivateKey:   privateKey,
		PublicKey:    publicKey,
		Subscription: *subscription,
		Subject:      subject,
	})
}
